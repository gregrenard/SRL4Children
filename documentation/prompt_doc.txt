CONTEXTE :
Tu es un expert en programmation et product lead. Tu dois rédiger une documentation complète du projet avec architecture détaillée, en te basant EXCLUSIVEMENT sur l'analyse du codebase existant. N'invente RIEN : toute information doit provenir directement du code, des commentaires, des fichiers de configuration ou des assets présents. Si un aspect n'est pas présent ou explicite dans le code, indique "Non implémenté ou non spécifié dans le code existant" et n'ajoute pas d'hypothèses, d'extrapolations, de roadmaps, de recommandations ou de suggestions. Analyse d'abord le codebase pour comprendre le domaine, les technologies et l'architecture uniquement à partir des éléments observables, avant de commencer la documentation. Ne fais aucune recommandation sur le matériel, les modèles ou tout autre élément ; déclare uniquement l'existant tel quel.

STRUCTURE DE DOCUMENTATION REQUISE :

WHY (Pourquoi ce module, à quoi il sert)

- Vision & Mission du système : Décris uniquement ce qui est inféré des commentaires, noms de composants ou use cases explicites dans le code. N'invente pas de vision si elle n'est pas documentée. Pas de roadmap ou de projections futures.
- Problématiques résolues : Liste seulement celles directement adressées par les implémentations existantes (ex. : fonctions spécifiques).
- Valeur ajoutée pour l'utilisateur/business : Base-toi sur les fonctionnalités implémentées ; omets si non explicite.
- Contexte métier et domaine d'application : Identifie le domaine à partir des technologies et patterns observés (ex. : web, IA), sans suppositions externes.

HOW (Architecture et mode de fonctionnement)

- Architecture générale avec schémas Mermaid : Crée des diagrammes reflétant uniquement la structure et les relations déduites du code (ex. : appels de fonctions, dépendances importées). Explique chaque schéma en détail, en citant les fichiers/lignes de code sources. Pas de recommandations sur du matériel ou des modèles ; déclare uniquement l'existant.
- Patterns architecturaux utilisés : Identifie seulement ceux observables (ex. : MVC si structure correspondante existe).
- Flow de traitement principal : Décris les séquences basées sur les appels réels dans le code, avec schémas Mermaid.
- Intégrations externes et dépendances : Liste uniquement celles importées ou configurées dans le code (ex. : via requirements.txt ou imports). Ne déclare que les dépendances vérifiées ; reste factuel et déclaratif, sans inventions.

WHAT (Description fine de chaque fichier, classe, fonction)

- Structure par modules avec détails techniques : Décris chaque fichier/dossier tel qu'il existe, avec rôle basé sur son contenu réel. N'ajoute pas de descriptions pour des éléments absents.
- API et interfaces publiques : Détaille seulement les endpoints/fonctions exposés dans le code, avec signatures exactes.
- Configuration et assets : Décris les fichiers de config/assets présents, sans ajouts.
- Points d'intégration et extensibilité : Mentionne uniquement ceux implémentés (ex. : hooks existants). Pas de suggestions d'extension future.

EXIGENCES QUALITÉ :

- Documentation super professionnelle : Utilise un ton factuel, précis et objectif.
- Tous les schémas doivent être expliqués en détail : Chaque Mermaid doit être suivi d'une explication textuelle citant le code source. Les schémas ne doivent pas inclure d'éléments non présents dans le code.
- Utiliser Mermaid pour tous les diagrammes : Intègre-les directement en Markdown pour les architectures générales, flows et tout autre schéma pertinent.
- Couvrir aspects techniques ET business : Mais seulement ceux observables ; omets ou marque comme non spécifiés si absents.
- Inclure sécurité, troubleshooting : Uniquement si implémentés (ex. : logging pour troubleshooting, auth pour sécurité). Pas de métriques : utilise des placeholders avec TODO pour les métriques (ex. : "TODO : Compléter manuellement les métriques"). N'invente pas de conseils génériques.
- Structure claire et navigable : Utilise tables des matières, en-têtes, émojis pour lisibilité, et liens relatifs entre fichiers (ex. : Lien vers API_REFERENCE.md).
- Exemples concrets et testables : Fournis uniquement des exemples extraits du code ou directement exécutables à partir de celui-ci. Pas d'exemples hypothétiques.

MÉTHODOLOGIE :

ANALYSE PRÉALABLE (OBLIGATOIRE ET STRICTE) :

- Explore la structure du projet : Liste exhaustivement les fichiers, dossiers et leur contenu réel (utilise des outils de lecture de code si disponibles).
- Identifie les composants principaux et leur rôle : Basé uniquement sur le code et commentaires.
- Comprends les technologies utilisées : Détecte via imports et fichiers (ex. : package.json pour Node).
- Détecte les patterns architecturaux : Seulement si évidents dans la structure.
- Identifie le domaine métier et les use cases : Infère des noms et implémentations ; pas d'assomptions externes.
- Vérification : Note tout élément non observable et marque-le comme tel. Vérifie l'absence de roadmaps, recommandations ou inventions.

ARCHITECTURE MAPPING :

- Crée schémas d'architecture générale : Uniquement à partir des relations code (ex. : diagrammes de classes si OOP observé), en utilisant Mermaid.
- Mappe les flows de données/traitement : Suivant les appels réels, avec schémas Mermaid.
- Identifie les intégrations externes : Liste factuelle.
- Documente le modèle de données : Si présent (ex. : schémas DB dans code). Vérifie que rien n'est ajouté ; reste déclaratif.

DOCUMENTATION TECHNIQUE :

- APIs et interfaces détaillées : Signatures exactes, sans ajouts.
- Configuration et paramétrage : Basé sur fichiers existants.
- Procédures de déploiement : Si scripts/fichiers dédiés existent ; sinon, "Non spécifié". Ne pas inventer de déploiements ; reste factuel.
- Guide de troubleshooting : Basé sur logs/erreurs gérées dans le code.
- Vérification finale : Relis la doc pour supprimer toute invention et assurer 100% fidélité au code.

LIVRABLES ATTENDUS :

- ARCHITECTURE_[PROJECT_NAME].md (document principal avec WHY/HOW/WHAT ; inclure placeholder pour métriques : "Métriques : TODO : Compléter manuellement les métriques existantes.").
- API_REFERENCE.md (documentation API détaillée, avec tables de endpoints si applicables).
- DEPLOYMENT_GUIDE.md (installation, déploiement, configuration – basé uniquement sur code existant ; reste déclaratif, sans inventions).
- TROUBLESHOOTING.md (diagnostic, résolution problèmes – limité aux implémentations ; inclure section "Problèmes Fréquents : TODO : Compléter manuellement les problèmes fréquents vérifiés." ; pas d'inventions d'informations non vérifiées).
- README.md (navigation, quick start – avec liens vers autres docs ; inclure sections : "Auteurs à contacter : TODO : Compléter manuellement les noms et contacts." et "Support et Contact : TODO : Compléter manuellement les informations de support (ex. : email, tickets).").
- Schémas Mermaid intégrés dans toute la documentation.

STRUCTURE FICHIERS :

- utiliser ou créer le répertoire "/documentation".
- Utiliser format Markdown avec émojis pour lisibilité.
- Tables des matières pour navigation.
- Liens croisés entre documents (relatifs pour portabilité).

Analyse automatiquement le contexte du projet pour adapter le vocabulaire, les diagrammes et les sections spécifiques au domaine détecté, MAIS TOUJOURS EN SE BASANT 100% SUR LE CODE EXISTANT, SANS INVENTION.